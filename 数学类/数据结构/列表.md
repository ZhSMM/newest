# 列表

## 分类

### 动态与静态

根据是否修改数据结构，所有操作大致分两种：

1. 静态：仅读取数据，数据结构的内容和组成一般不变，如get、find、search；
2. 动态：需要进行数据写入，数据结构的局部或整体将发生改变，如insert、remove；

与操作方式对应，数据元素的存储与组织方式也分两种：

1. 静态：
   - 数据空间整体创建或销毁；
   - 数据元素的物理存储次序与其逻辑次序严格一致；
   - 可支持高效的静态操作；
   - 比如向量，元素的物理地址与其逻辑次序线性对应；
2. 动态：
   - 为各元素动态地分配和回收物理空间；
   - 逻辑上相邻的元素记录彼此的物理地址，在逻辑上形成一个整体；
   - 可支持高效的动态操作；

### 向量与列表

向量是静态存储数据，而列表是动态的存储数据，列表中的每一项称为节点。同时，向量可以循秩访问，而列表则采用循位置访问。

## 列表ADT

### 列表节点ADT：

|      操作       |                      功能                       |
| :-------------: | :---------------------------------------------: |
|     pred()      |             当前节点前驱节点的位置              |
|     succ()      |             当前节点后继节点的位置              |
|     data()      |              当前节点所存储的对象               |
| insertAsPred(e) | 插入前驱节点，存入被引用的对象e，返回新节点位置 |
| insertAsSucc(e) | 插入后继节点，存入被引用的对象e，返回新节点位置 |

### 实现：

```c++
#define Posi(T) ListNode<T>*  // 列表节点位置

template <typename T>
struct ListNode{ // 双向链表形式实现列表节点模板类
    T data; //数值
    Posi(T) pred;  // 前驱
    Posi(T) succ;  // 后继
    ListNode(){}  // 针对header和trailer的构造
    ListNode(T e,Posi(T) p=NULL,Posi(T) s=NULL)
        :data(e),pred(p),succ(s){}  //默认构造器
    Posi(T) insertAsPred(T const &e);
    Posi(T) insertAsSucc(T const &e);
};
```

### 列表ADT